# -*- coding: utf-8 -*-
"""Influential user in social networks.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18G7OwjIET60sU1inr4q_BKHOK1eEWRTS

**Installing Libraries**
"""

pip install igraph

pip install mlxtend

"""**Importing** **Libraries**"""

from igraph import *

"""**Creating new graph object**"""

g=Graph()

"""**About** **Dataset**

nodeId.edges : The edges in the ego network for the node 'nodeId'. Edges are undirected for facebook, and directed (a follows b) for twitter and gplus. The 'ego' node does not appear, but it is assumed that they follow every node id that appears in this file.

nodeId.circles : The set of circles for the ego node. Each line contains one circle, consisting of a series of node ids. The first entry in each line is the name of the circle.

nodeId.feat : The features for each of the nodes that appears in the edge file.

nodeId.egofeat : The features for the ego user.

nodeId.featnames : The names of each of the feature dimensions. Features are '1' if the user has this property in their profile, and '0' otherwise. This file has been anonymized for facebook users, since the names of the features would reveal private data.

**Adding New Vertex**
"""

#function takes two arguments the graph object and the name of the new vertex.

def addVertex(g,name_str):
    try:
        if(name_str not in g.vs['name']):
            print('Inserted node ',name_str)
            g.add_vertex(name=name_str)
        else:
            print ('Node ',name_str,' already present')
            print(g.vs.find(name_str).index)
    except KeyError:
        g.add_vertex(name=name_str)
    return g

"""**Writing a tuple to a file**"""

#function takes two arguments: the file object and the tuple.
#The function first converts the tuple to a string by joining
#the elements with a space character. The function then writes the string to
#the file object.

def write_tuple_to_file(f,t):
    string=str(t[0])+' '+str(t[1])+'\n'
    f.write(string)

"""**Retrieves the names of the vertices**"""

#The function takes two arguments: the graph object and the edge object.
#function first gets the names of the vertices connected by the edge.
#function then returns a tuple containing the names of the vertices.

def retrieve_edge_name_tuple(g,t):
    a=(g.vs[t[0]]['name'],g.vs[t[1]]['name'])
    return a

"""**Loading a dataset of edges into a graph object.**"""

#function first opens the file and reads the lines.
 #The function then adds each edge to the graph object.
 #The function finally simplifies the graph object.

def load_dataset(fileName,g):
    fileNums=[0]
    for i,eachNum in enumerate(fileNums):
        print(eachNum)
        fileName="/Datasets/facebook/"+str(eachNum)+".edges"
        print('fileName=',fileName)
        f=open(fileName)
        line=f.readline()
        while(line!=''):
            c=(line.split())
            g=addVertex(g,c[0])
            g=addVertex(g,c[1])
            print('Adding ',c[0],'-->',c[1])
            g.add_edge(c[0],c[1])
            line=f.readline()
    g.simplify()
    return

load_dataset('abd',g)
print(len(g.vs))

"""**Centrality Measures**"""

def calculate_eigen(g):
    eigen=g.evcent(directed=False)
    for i in range(1,6):
        maxVal=max(eigen)
        print(i,'==node',g.vs[eigen.index(maxVal)]['name'],' with score of ',maxVal)
        eigen.remove(maxVal)
    eigen=g.evcent(directed=False)
    return eigen

def calculate_closeness(g):
    close=g.closeness(g.vs)
    for i in range(1,6):
        maxVal=max(close)
        print(i,'==node',g.vs[close.index(maxVal)]['name'],' with score of ',maxVal)
        close.remove(maxVal)
    close=g.closeness(g.vs)
    return close

def calculate_between(g):
    between=g.betweenness(g.vs)
    for i in range(1,6):
        maxVal=max(between)
        print(i,'==node',g.vs[between.index(maxVal)]['name'],' with score of ',maxVal)
        between.remove(maxVal)
    between=g.betweenness(g.vs)
    return between

print('Eigen Vector')
global eigen
eigen=calculate_eigen(g)

global close
print('Closeness')
close=calculate_closeness(g)

global between
print('Betweenness')
between=calculate_between(g)

print(close)

"""**USING ASSOCIATION RULE LEARNING TECHNIQUE**"""

from mlxtend.preprocessing import TransactionEncoder
from mlxtend.frequent_patterns import apriori, association_rules
import pandas as pd
# Sample data of users and their interests
data = [['User1', 'Interest1', 'Interest2'],
        ['User2', 'Interest1', 'Interest3'],
        ['User3', 'Interest2'],
        ['User4', 'Interest1', 'Interest2', 'Interest3'],
        ['User5', 'Interest2', 'Interest3']]

# Convert the data to a binary encoded format
te = TransactionEncoder()
te_ary = te.fit(data).transform(data)
df = pd.DataFrame(te_ary, columns=te.columns_)

# Apply the Apriori algorithm to find frequent itemsets
frequent_itemsets = apriori(df, min_support=0.2, use_colnames=True)

# Generate association rules from the frequent itemsets
rules = association_rules(frequent_itemsets, metric="confidence", min_threshold=0.7)

# Sort the rules by confidence in descending order
rules = rules.sort_values(by='confidence', ascending=False)

# Print the influential users based on the association rules
influential_users = rules['antecedents'].values.flatten()
print("Most influential users based on shared interests:")
print(influential_users)

"""**In this output most influential user is User4/ User4 shares interests with 7 other users. Least Influential user is User1. since user 1 shares interest with 2 other users.**"""